(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{175:function(a,t,r){"use strict";r.r(t);var e=r(0),n=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("div",{staticClass:"content"},[r("h2",{attrs:{id:"同步集合"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#同步集合","aria-hidden":"true"}},[a._v("#")]),a._v(" 同步集合")]),a._v(" "),r("p",[a._v("java.util.concurrent包中包含了对Java集合框架的一些添加。这些最容易通过提供的收集界面进行分类：")]),a._v(" "),r("p",[a._v("BlockingQueue定义了一种先入先出的数据结构，当您尝试添加到完整队列或从空队列中检索时，该数据结构会阻塞或超时。\nConcurrentMap是定义有用的原子操作的java.util.Map的子接口。这些操作仅在键存在时才删除或替换键值对，或者仅在键不存在时才添加键值对。使这些操作原子化有助于避免同步。 ConcurrentMap的标准通用实现是ConcurrentHashMap，它是HashMap的并发模拟。\nConcurrentNavigableMap是支持近似匹配的ConcurrentMap的子接口。 ConcurrentNavigableMap的标准通用实现是ConcurrentSkipListMap，它是TreeMap的并发模拟。\n所有这些集合通过定义将对象添加到集合的操作与访问或移除该对象的后续操作之间的间隔之前的关系来帮助避免内存一致性错误。")]),a._v(" "),r("h2",{attrs:{id:"atomicinteger"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#atomicinteger","aria-hidden":"true"}},[a._v("#")]),a._v(" AtomicInteger")]),a._v(" "),r("h2",{attrs:{id:"并发随机数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#并发随机数","aria-hidden":"true"}},[a._v("#")]),a._v(" 并发随机数")]),a._v(" "),r("p",[a._v("在JDK 7中，对于希望使用多线程或ForkJoinTasks中的随机数的应用程序，java.util.concurrent包含一个便利类ThreadLocalRandom。")]),a._v(" "),r("p",[a._v("对于并发访问，使用ThreadLocalRandom而不是Math.random（）可以减少争用并最终提高性能。")]),a._v(" "),r("p",[a._v("所有你需要做的就是调用ThreadLocalRandom.current（），然后调用它的一个方法来检索一个随机数。 这里有一个例子：")]),a._v(" "),r("p",[a._v("int r = ThreadLocalRandom.current（）.nextInt（4，77）;")])])}],!1,null,null,null);n.options.__file="other.md";t.default=n.exports}}]);