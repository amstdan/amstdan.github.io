(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{164:function(e,r,a){"use strict";a.r(r);var t=a(0),n=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"executors"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#executors","aria-hidden":"true"}},[e._v("#")]),e._v(" Executors")]),e._v(" "),a("p",[e._v("由Runnable对象定义的新线程完成的任务与线程对象定义的线程本身之间存在紧密联系。 这适用于小型应用程序，但在大型应用程序中，将线程管理和创建与应用程序的其余部分分开是有意义的。 封装这些功能的对象被称为执行者executors。")]),e._v(" "),a("h2",{attrs:{id:"executor-interfaces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#executor-interfaces","aria-hidden":"true"}},[e._v("#")]),e._v(" Executor Interfaces")]),e._v(" "),a("p",[e._v("Executor，一个支持启动新任务的简单界面。\nExecutorService，Executor的一个子接口，它增加了帮助管理生命周期的特性，既有单独的任务，也有执行器本身。\nScheduledExecutorService是ExecutorService的子接口，支持将来和/或定期执行任务。")]),e._v(" "),a("h2",{attrs:{id:"线程池"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程池","aria-hidden":"true"}},[e._v("#")]),e._v(" 线程池")]),e._v(" "),a("p",[e._v("Runnable和Callable的区别是：\n(1)Callable规定的方法是call()，Runnable规定的方法是run()。其中Runnable可以提交给Thread来包装下，直接启动一个线程来执行，而Callable则一般都是提交给ExecuteService来执行。\n(2)Callable的任务执行后可返回值，而Runnable的任务是不能返回值得\n(3)call方法可以抛出异常，run方法不可以\n(4)运行Callable任务可以拿到一个Future对象，c表示异步计算的结果。")]),e._v(" "),a("p",[e._v("java.util.concurrent中的大多数执行器实现使用线程池，其中包含工作线程。这种线程与其执行的Runnable和Callable任务分开存在，并且通常用于执行多个任务。")]),e._v(" "),a("p",[e._v("使用工作线程最大限度地减少了线程创建所带来的开销线程对象使用大量内存，而在大规模应用程序中，分配和释放许多线程对象会产生显着的内存管理开销。")]),e._v(" "),a("p",[e._v("一种常见的线程池类型是固定线程池。这种类型的池总是有指定数量的线程在运行;如果某个线程在仍处于使用状态时以某种方式终止，则会自动替换为新线程。任务通过内部队列提交给池，每当有更多的活动任务比线程更多时，内部队列就会保存额外的任务。")]),e._v(" "),a("p",[e._v("固定线程池的一个重要优点是使用它的应用程序会优雅地降级。为了理解这一点，考虑一个Web服务器应用程序，每个HTTP请求由一个单独的线程处理。如果应用程序只是为每个新的HTTP请求创建一个新线程，并且系统接收到的请求数量超过了它可以立即处理的数量，那么当所有线程的开销超过系统容量时，应用程序将突然停止响应所有请求。由于可以创建的线程数量受到限制，应用程序不会尽快处理HTTP请求，但它将尽可能快地为系统提供服务。")]),e._v(" "),a("p",[e._v("创建使用固定线程池的执行程序的一种简单方法是调用java.util.concurrent.Executors中的newFixedThreadPool工厂方法。此类还提供以下工厂方法：")]),e._v(" "),a("p",[e._v("newCachedThreadPool方法创建一个具有可扩展线程池的执行程序。 该执行程序适用于启动许多短期任务的应用程序。\nnewSingleThreadExecutor方法创建一个执行器，一次执行一个任务。\n几种工厂方法是上述执行程序的ScheduledExecutorService版本。\n如果以上工厂方法提供的执行程序都不符合您的需求，则构建java.util.concurrent.ThreadPoolExecutor或java.util.concurrent.ScheduledThreadPoolExecutor的实例将为您提供其他选项。")]),e._v(" "),a("h2",{attrs:{id:"fork-join"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fork-join","aria-hidden":"true"}},[e._v("#")]),e._v(" fork/join")]),e._v(" "),a("p",[e._v("fork / join框架是ExecutorService接口的实现，可帮助您利用多个处理器。 它被设计用于可以递归地分解成小块的工作。 目标是使用所有可用的处理能力来提高应用程序的性能。")]),e._v(" "),a("p",[e._v("与任何ExecutorService实现一样，fork / join框架将任务分配给线程池中的工作线程。 fork / join框架是独特的，因为它使用了工作窃取算法。 用尽事情的工作线程可以从其他仍然繁忙的线程中窃取任务。")]),e._v(" "),a("p",[e._v("fork / join框架的中心是ForkJoinPool类，它是AbstractExecutorService类的扩展。 ForkJoinPool实现了核心工作窃取算法，并且可以执行ForkJoinTask进程。")]),e._v(" "),a("p",[e._v("java.util.streams包中的方法使用fork / join框架的另一个实现")])])}],!1,null,null,null);n.options.__file="executors.md";r.default=n.exports}}]);