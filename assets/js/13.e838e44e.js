(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{181:function(e,t,r){"use strict";r.r(t);var n=r(0),a=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程","aria-hidden":"true"}},[e._v("#")]),e._v(" 线程")]),e._v(" "),r("h2",{attrs:{id:"进程和线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程","aria-hidden":"true"}},[e._v("#")]),e._v(" 进程和线程")]),e._v(" "),r("p",[e._v("进程是资源分配的最小单位,线程是CPU调度的最小单位。\n在单核系统中，同一时刻只有一个线程执行。\n一个进程有一个独立的执行环境。一个进程通常拥有一套完整的私有基本运行时资源。特别是每个进程都有自己的内存空间。\n线程存在于一个进程中，每个进程至少有一个线程。线程共享进程的资源，包括内存和打开的文件。")]),e._v(" "),r("h2",{attrs:{id:"创建线程方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建线程方式","aria-hidden":"true"}},[e._v("#")]),e._v(" 创建线程方式")]),e._v(" "),r("p",[e._v("创建一个线程实例有两种方式\n一种是作为Thread的子类，继承Thread。这种方式在简单的应用程序中更容易使用，但是线程任务和线程绑定了。\n一种是提供一个Runnable对象，实现Runnable对象。推荐使用这种方式，线程任务和线程对象的分离，更加灵活。并且不用受限只能是Thread子类。")]),e._v(" "),r("h2",{attrs:{id:"使用sleep暂停执行"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#使用sleep暂停执行","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用sleep暂停执行")]),e._v(" "),r("p",[e._v("Thread.sleep造成当前线程暂停执行一段指定的时间。\n可以使CPU时间用于执行应用程序的其它线程或者计算机系统上的其他应用程序。")]),e._v(" "),r("p",[e._v("调用sleep并不能保证一定精确的暂停声明的时间，受限于由底层操作系统提供的设施。并且sleep周期可以通过中断来终止。")]),e._v(" "),r("h2",{attrs:{id:"中断-interrupts"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#中断-interrupts","aria-hidden":"true"}},[e._v("#")]),e._v(" 中断(Interrupts)")]),e._v(" "),r("p",[e._v("Java中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理中断。甚至可以不理会该请求。")]),e._v(" "),r("p",[e._v("interrupt() 中断线程   唯一能将中断状态设置为true的方法。\nisInterrupted() 测试线程是否已经中断。线程的中断状态不受该方法的影响。\ninterrupted  测试当前线程是否已经中断。线程的中断状态 由该方法清除。")]),e._v(" "),r("p",[e._v("既然Java中断机制只是设置被中断线程的中断状态，那么被中断线程该做些什么？")]),e._v(" "),r("p",[e._v("显然，作为一种协作机制，不会强求被中断线程一定要在某个点进行处理。实际上，被中断线程只需在合适的时候处理即可，如果没有合适的时间点，甚至可以不处理，这时候在任务处理层面，就跟没有调用中断方法一样。“合适的时候”与线程正在处理的业务逻辑紧密相关，例如，每次迭代的时候，进入一个可能阻塞且无法中断的方法之前等，但多半不会出现在某个临界区更新另一个对象状态的时候，因为这可能会导致对象处于不一致状态。")]),e._v(" "),r("p",[e._v("处理时机决定着程序的效率与中断响应的灵敏性。频繁的检查中断状态可能会使程序执行效率下降，相反，检查的较少可能使中断请求得不到及时响应。如果发出中断请求之后，被中断的线程继续执行一段时间不会给系统带来灾难，那么就可以将中断处理放到方便检查中断，同时又能从一定程度上保证响应灵敏度的地方。当程序的性能指标比较关键时，可能需要建立一个测试模型来分析最佳的中断检测点，以平衡性能和响应灵敏性。")]),e._v(" "),r("p",[e._v("1 调用会产生 InterruptedException的方法。\ntry {\nThread.sleep(4000);\n} catch (InterruptedException e) {\n// We've been interrupted: no more messages.\nreturn;\n}\n2 调用不会产生InterruptedException的方法。\nif (Thread.interrupted()) {\n// We've been interrupted: no more crunching.\nreturn;\n}")]),e._v(" "),r("h2",{attrs:{id:"joins"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#joins","aria-hidden":"true"}},[e._v("#")]),e._v(" Joins")]),e._v(" "),r("p",[e._v("join()方法允许一个线程等待另一个线程的完成。\n例如，线程t调用\nt.join();\n将造成当前线程停止执行直到t线程终止。重载的join方法还允许设置等待时间，当然后这个时间也是受限于OS。并不一定精确。")])])}],!1,null,null,null);a.options.__file="Thread.md";t.default=a.exports}}]);