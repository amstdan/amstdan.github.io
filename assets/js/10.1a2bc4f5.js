(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{184:function(e,t,a){"use strict";a.r(t);var s=a(0),n=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"hashmap原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashmap原理","aria-hidden":"true"}},[e._v("#")]),e._v(" HashMap原理")]),e._v(" "),a("p",[e._v("当HashMap被初始化时，会创建一个Entry数组。")]),e._v(" "),a("p",[e._v("数组里每个存储单元可以存放一个Entry, 在Entry对象中包括Key, Value, hash，还有对下一个Entry对象的引用，这样就可以形成一个Entry链。把这个Entry链的所有元素可以抽象看作是放在一个bucket(桶)里面的，一个bucktet里面的元素的hashCode是相同的。")]),e._v(" "),a("p",[e._v("添加元素时，首先，调用Key的HashCode()方法，将得到的HashCode值除以数组的长度。根据所得余数来确定数组索引位置，即bucket的位置。由于HashMap中元素的Key是不能相同的。这里所谓的相同是用equals()方法进行判断的。因此，确定了bucket位置，还要判断Entry链中是否有相同的Key。如果存在相同的key,将被添加的元素的Value替换掉原来的Value，如果不存在相同的key,将被添加的元素,添加到Entry链的链头。\n默认的负载因子大小为0.75，就是说，当一个map填满了75%的数组时，将会创建一个比原来数组大一倍的数组，然后将元素添加到新数组中。")]),e._v(" "),a("p",[e._v("查询元素时，首先根据Key的hashCode()方法找到bucket位置,然后遍历整个bucket找到那个Key元素的Entry。")])])}],!1,null,null,null);n.options.__file="HashMap基本原理.md";t.default=n.exports}}]);