(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{165:function(a,e,t){"use strict";t.r(e);var r=t(0),i=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"java并发基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java并发基础","aria-hidden":"true"}},[a._v("#")]),a._v(" Java并发基础")]),a._v(" "),t("h2",{attrs:{id:"并发的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并发的特点","aria-hidden":"true"}},[a._v("#")]),a._v(" 并发的特点")]),a._v(" "),t("p",[a._v("并发，是指在一个时间段中，在"),t("strong",[a._v("一个处理器上")]),a._v("有几个程序都处于启动运行到运行完毕之间，但任一个时刻点上只有一个程序在处理机上运行。\n并发不同于并行，并行是同一时刻点能有多个程序能同时运行，并行只能发生于多核处理器的系统中。")]),a._v(" "),t("p",[a._v("使用并发的主要目的就是为了提高资源利用率和程序性能。在没有操作系统的原始计算机中，自始自终只执行一个程序，效率很低，且不能很好的利用计算机资源。")]),a._v(" "),t("p",[a._v("多进程和多线程是实现并发的手段。")]),a._v(" "),t("h2",{attrs:{id:"线程的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的生命周期","aria-hidden":"true"}},[a._v("#")]),a._v(" 线程的生命周期")]),a._v(" "),t("p",[a._v("在Java语言中，线程有六种状态：")]),a._v(" "),t("ul",[t("li",[a._v("NEW    \t\t\t初始状态， 线程被构建，但是还没有调用start()方法。")]),a._v(" "),t("li",[a._v('RUNNABLE    运行状态，Java线程将操作系统的就绪(可以占用CPU)和运行(正在占用CPU)两种状态统称为"运行中"')]),a._v(" "),t("li",[a._v("BLOCKED  \t\t阻塞状态")]),a._v(" "),t("li",[a._v("WAITING  \t等待状态")]),a._v(" "),t("li",[a._v("TIME_WAITING  超时等待状态")]),a._v(" "),t("li",[a._v("TERMINATED    终止状态，表示当前线程已经执行完毕")])]),a._v(" "),t("p",[a._v("状态发生改变的条件\nNEW - > RUNNABLE    start()\nRUNABLE ->  WAITING   wait(), join(), LockSupport.lock()\nWAITING ->  RUNNABLE      Object.notify(), Object.notifyAll()\nRUNABLE ->  TIMED_WAITING  wait(long timeout), sleep(long), join(long), LockSupport.parkNanos(), LockSupport.parkUtil()\nTIMED_WAITING ->  RUNNABLE  1. 当超时等待时间到达后，线程会再回到RUNNABLE的状态。2. Object.notify(), Object.notifyAll()\nRUNABLE -> BLOCKED  等待获取锁的时候\nBLOCKED -> RUNABLE  获取到锁的时候\nRUNNABLE -> TERMINATED  执行完毕")]),a._v(" "),t("h2",{attrs:{id:"线程方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 线程方法")]),a._v(" "),t("h3",{attrs:{id:"interrupted-（中断）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#interrupted-（中断）","aria-hidden":"true"}},[a._v("#")]),a._v(" interrupted （中断）")]),a._v(" "),t("p",[a._v("有时候我们希望在线程在自然结束（run()方法执行完）之前就停止它们，可能因为用户取消了操作或者应用程序需要快速关闭。Java没有提供\n任何机制，来安全强迫线程停止手头工作，它提供了中断。")]),a._v(" "),t("p",[a._v("每一个线程都有一个boolean类型的中断状态，其它线程可以改变目标线程的这个状态值。当这个状态值为true时\n并不意味着必然停止目标线程正在进行的功能，它仅仅传递了请求中断的消息。 线程可以通过检查这个状态，来响应中断。如果线程不检查状态，中断状态可以一直为true。")]),a._v(" "),t("p",[a._v("仅仅通过线程代码去检查中断状态，还不能完全实现中断机制。因为对于不处于运行状态的线程来说，它没法检查状态，即使它的中断状态为true, 也没法响应中断。所以，在java中一些造成阻塞的方法如sleep, wait()，\n它会监控中断状态，它们对中断状态的响应表现为清除中断状态，抛出InterruptedException。这表示阻塞状态会因为中断状态而提前结束。")]),a._v(" "),t("p",[a._v("Thread类提供了三个关于中断的方法\npublic void interrupt() {...}   //设置中断状态为true\npublic boolean isInterrupted() {...}   //返回线程的中断状态。线程可以调用这个方法来检查状态，从而响应中断。\npublic static boolean interrupted() {...} //清除当前中断状态，并返回清除之前的状态。")]),a._v(" "),t("h3",{attrs:{id:"join"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#join","aria-hidden":"true"}},[a._v("#")]),a._v(" join")]),a._v(" "),t("p",[a._v("join可以使用两个异步的线程变的同步，并行变成串行。\n如有线程A和线程B，在线程A中调用线程B的join方法，可以使用线程A进入等待状态，然后开始执行线程B，直到线程B执行完，再执行线程A。")]),a._v(" "),t("h3",{attrs:{id:"sleep和wait"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sleep和wait","aria-hidden":"true"}},[a._v("#")]),a._v(" sleep和wait")]),a._v(" "),t("p",[a._v("调用线程的sleep方法，会让线程进入等待状态(TIMED_WAITING)，线程会让出CPU，直到设置的休眠时间完，线程再进行RUNNABLE状态。\n调用线程的wait()或wait(long timeout),方法，同样也会让线程进入等待状态(TIMED_WAITING或WAITING)，与sleep不同的是, wati()方法只能在\n同步代码块或同步方法中使用，否则会抛出异常。wait()使线程让出CPU并释放在同步块的所占用的锁，让其它线程可以占用，直到其它线程调用 notify或notifyAll方法，再恢复运行。\n如果sleep是在同步块或同步方法中使用，sleep并不会释放锁，只是让出CPU暂停执行。")]),a._v(" "),t("h3",{attrs:{id:"yeild"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#yeild","aria-hidden":"true"}},[a._v("#")]),a._v(" yeild")]),a._v(" "),t("p",[a._v("yeild()方法暂停当前正在执行的线程，并分配给当前线程相同优先级的线程。yeild()方法不会改变线程状态，依然是RUNNABLE状态(从运行行状态变成可运行状态)。\n实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。")]),a._v(" "),t("h2",{attrs:{id:"jmm-java-memory-model"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jmm-java-memory-model","aria-hidden":"true"}},[a._v("#")]),a._v(" JMM(Java Memory Model)")]),a._v(" "),t("p",[a._v("java 内存模型，定义了共享内存系统中多线程程序读写操作的规范。通过这些规范，从而保证指令执行的正确性。")]),a._v(" "),t("h3",{attrs:{id:"原子性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原子性","aria-hidden":"true"}},[a._v("#")]),a._v(" 原子性")]),a._v(" "),t("p",[a._v("在一个原子性操作中，CPU不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。\n例如，i++ 不是一个原子性的操作，它可以分解为以下原子性的操作。\n读取变量i"),t("br"),a._v("\n给i 加1\n将 +1的值存回内存")]),a._v(" "),t("h3",{attrs:{id:"可见性-一致性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可见性-一致性","aria-hidden":"true"}},[a._v("#")]),a._v(" 可见性 (一致性)")]),a._v(" "),t("p",[a._v("多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。")]),a._v(" "),t("p",[a._v("所有的变量都存储在主内存中，每个线程有自己的工作内存，线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，\n线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。\n不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。\nJava内存模型规定了如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。")]),a._v(" "),t("h3",{attrs:{id:"有序性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有序性","aria-hidden":"true"}},[a._v("#")]),a._v(" 有序性")]),a._v(" "),t("p",[a._v("程序在执行时，并不会严格按照程序顺序执行。")]),a._v(" "),t("p",[a._v("编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。\n指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。")]),a._v(" "),t("p",[a._v("JMM内存模型定义了规则来禁止特定类型的编译器重排序和处理器重排序。")]),a._v(" "),t("p",[a._v("happens-before\njava内存模型规范使用happens-before的概念来指定两个操作之间的执行顺序。\n如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见。")]),a._v(" "),t("p",[a._v("程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。\n监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。\nvolatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。\n传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。\nstart()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。\njoin()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。\n程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。\n对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。\n注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！")]),a._v(" "),t("h2",{attrs:{id:"synchronized"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronized","aria-hidden":"true"}},[a._v("#")]),a._v(" synchronized")]),a._v(" "),t("h2",{attrs:{id:"volatile"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#volatile","aria-hidden":"true"}},[a._v("#")]),a._v(" volatile")]),a._v(" "),t("h2",{attrs:{id:"final"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#final","aria-hidden":"true"}},[a._v("#")]),a._v(" final")]),a._v(" "),t("h2",{attrs:{id:"线程安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程安全","aria-hidden":"true"}},[a._v("#")]),a._v(" 线程安全")])])}],!1,null,null,null);i.options.__file="base.md";e.default=i.exports}}]);