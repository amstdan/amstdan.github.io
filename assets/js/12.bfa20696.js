(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{182:function(e,n,t){"use strict";t.r(n);var a=t(0),r=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h2",{attrs:{id:"同步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同步","aria-hidden":"true"}},[e._v("#")]),e._v(" 同步")]),e._v(" "),t("h2",{attrs:{id:"线程干扰（thread-interference）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程干扰（thread-interference）","aria-hidden":"true"}},[e._v("#")]),e._v(" 线程干扰（Thread Interference）")]),e._v(" "),t("p",[e._v("多个线程访问共享数据时出现错误。")]),e._v(" "),t("p",[e._v("如对于变量c, 多个线程调用c++，或c--。")]),e._v(" "),t("h2",{attrs:{id:"内存一致性错误（memory-consistency-errors）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存一致性错误（memory-consistency-errors）","aria-hidden":"true"}},[e._v("#")]),e._v(" 内存一致性错误（Memory Consistency Errors）")]),e._v(" "),t("p",[e._v("由于共享内存不一致而导致的错误。多个线程对共享数据却有不一致的值。")]),e._v(" "),t("h2",{attrs:{id:"同步方法-（synchronized-methods）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同步方法-（synchronized-methods）","aria-hidden":"true"}},[e._v("#")]),e._v(" 同步方法 （Synchronized Methods）")]),e._v(" "),t("p",[e._v("Java提供了两个基本的同步方法：同步方法和同步语句。")]),e._v(" "),t("h2",{attrs:{id:"内部锁和同步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内部锁和同步","aria-hidden":"true"}},[e._v("#")]),e._v(" 内部锁和同步")]),e._v(" "),t("p",[e._v("同步的机制是建立在内部锁的基础上的。强制对一个对象状态的独占性访问，建立“happens-before”关系，happens-before关系对可见性很重要。")]),e._v(" "),t("p",[e._v("当一个线程访问其他线程已经占有的锁时，请求线程将被阻塞。然而内部锁是可重进入的，因此线程在试图获得它自己占有的锁时，请求会成功。")]),e._v(" "),t("p",[e._v("能过一个请求计数和一个占有它的线程来实现可重入。\n同步代码直接或间接地调用也包含同步代码的方法，并且这两组代码使用同一个锁。 没有可重入同步，同步代码将不得不采取许多额外的预防措施以避免线程导致自身阻塞。\n子类重写父类同步方法，并调用父类的同步方法。")]),e._v(" "),t("p",[e._v("意思是: 不可打断的操作")]),e._v(" "),t("p",[e._v("Java 中的原子操作:")]),e._v(" "),t("p",[e._v("读取或改变引用类型的引用\n读取或改变基本类型(long 和 double 除外)\n读取或改变所有volatile类型的变量(包括引用, long, double)\n原子操作不会被拆分, 所以不用担心线程干扰(Thread Interference)的问题, 但是却仍然要注意内存一致性(Memory Consistency)的问题.")]),e._v(" "),t("p",[e._v("使用volatile可以避免内存一致性错误, 因为写入volatile 变量建立了一种 happen-before 的关系: 写入总比后续读先.")]),e._v(" "),t("p",[e._v("synchronized method 和 synchronized statements 会保证原子操作.")]),e._v(" "),t("p",[e._v("happen-before是什么意思。")]),e._v(" "),t("h2",{attrs:{id:"活跃度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#活跃度","aria-hidden":"true"}},[e._v("#")]),e._v(" 活跃度")]),e._v(" "),t("p",[e._v("一个并发应用及时执行的能力称作活跃度。")]),e._v(" "),t("p",[e._v("死锁\n死锁指两个或者多个线程永远阻塞，彼此等待的情形。")]),e._v(" "),t("p",[e._v("饥饿\n饥饿指线程无法访问共享数据，并且无法继续执行。")]),e._v(" "),t("p",[e._v("活锁\n一个线程经常对另一个线程作回应，导致无法继续运行。\n相当于让路，两个人总是同时向一个方向让路，导致双方无法继续运行。")]),e._v(" "),t("h2",{attrs:{id:"保护块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#保护块","aria-hidden":"true"}},[e._v("#")]),e._v(" 保护块")]),e._v(" "),t("p",[e._v("wait函数\n调用线程的sleep，yield方法时，线程并不会让出对象锁，wait却不同。\nwait函数必须在同步代码块中调用(也就是当前线程必须持有对象的锁)，他的功能是这样的：\n我累了，休息一会儿，对象的锁你们拿去用吧，CPU也给你们。\n调用了wait函数的线程会一直等待，直到有其他线程调用了同一个对象的notify或者notifyAll方法才能被唤醒，需要注意的是：被唤醒并不代表立即获得对象的锁。也就是说，一个线程调用了对象的wait方法后，他需要等待两件事情的发生：\n有其他线程调用同一个对象的notify或者notifyAll方法（调用notify/notifyAll方法之前）\n被唤醒之后重新获得对象的锁(调用notify/notifyAll方法之后)\n才能继续往下执行后续动作。\n如果一个线程调用了某个对象的wait方法，但是后续并没有其他线程调用该对象的notify或者notifyAll方法，则该线程将会永远等下去…")]),e._v(" "),t("p",[e._v("notify和notifyAll方法\nnotofy/notifyAll方法也必须在同步代码块中调用(也就是调用线程必须持有对象的锁)，他们的功能是这样的：\n女士们，先生们请注意，锁的对象我即将用完，请大家醒醒，准备一下，马上你们就能使用锁了。\n不同的是，notify方法只会唤醒一个正在等待的线程(至于唤醒谁，不确定！)，而notifyAll方法会唤醒所有正在等待的线程。还有一点需要特别强调：调用notify和notifyAll方法后，当前线程并不会立即放弃锁的持有权，而必须要等待当前同步代码块执行完才会让出锁。\n如果一个对象之前没有调用wait方法，那么调用notify方法是没有任何影响的。")]),e._v(" "),t("p",[e._v("wait()与sleep()的区别：\n1.首先sleep()是Thread()类的方法，而wait()是Object类的方法，包括notify()，notifyAll()都是Object类的方法")]),e._v(" "),t("pre",[t("code",[e._v("   2.sleep()方法是休眠，阻塞线程的同时仍然会持有锁，也就是说它休眠期间其他线程仍然无法获得锁，同时sleep()休眠时自动醒           的；而调用wait()方法时，则自动释放锁，也就是其他线程可以获得锁，而且wait()是无法自动醒的，只有通过notify()或 notifyAll()         才行。\n")])]),e._v(" "),t("h2",{attrs:{id:"不可变类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不可变类","aria-hidden":"true"}},[e._v("#")]),e._v(" 不可变类")]),e._v(" "),t("p",[e._v("使用Immutable类的好处：\n1）Immutable对象是线程安全的，可以不用被synchronize就在并发环境中共享\n2）Immutable对象简化了程序开发，因为它无需使用额外的锁机制就可以在线程间共享\n3）Immutable对象提高了程序的性能，因为它减少了synchroinzed的使用\n4）Immutable对象是可以被重复使用的，你可以将它们缓存起来重复使用，就像字符串字面量和整型数字一样。你可以使用静态工厂方法来提供类似于valueOf（）这样的方法，它可以从缓存中返回一个已经存在的Immutable对象，而不是重新创建一个。")]),e._v(" "),t("p",[e._v("immutable也有一个缺点就是会制造大量垃圾，由于他们不能被重用而且对于它们的使用就是”用“然后”扔“，字符串就是一个典型的例子，它会创造很多的垃圾，给垃圾收集带来很大的麻烦。当然这只是个极端的例子，合理的使用immutable对象会创造很大的价值")]),e._v(" "),t("p",[e._v("如何在Java中写出Immutable的类？")]),e._v(" "),t("p",[e._v("要写出这样的类，需要遵循以下几个原则：\n1）immutable对象的状态在创建之后就不能发生改变，任何对它的改变都应该产生一个新的对象。\n2）Immutable类的所有的属性都应该是final的。\n3）对象必须被正确的创建，比如：对象引用在对象创建过程中不能泄露(leak)。\n4）对象应该是final的，以此来限制子类继承父类，以避免子类改变了父类的immutable特性。\n5）如果类中包含mutable类对象，那么返回给客户端的时候，返回该对象的一个拷贝，而不是该对象本身（该条可以归为第一条中的一个特例）")]),e._v(" "),t("h2",{attrs:{id:"lock-类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lock-类","aria-hidden":"true"}},[e._v("#")]),e._v(" Lock 类")]),e._v(" "),t("p",[e._v("synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？\n　　在上面一篇文章中，我们了解到如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：\n　　1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；\n　　2）线程执行发生异常，此时JVM会让线程自动释放锁。\n　　那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。\n　　因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。\n　　再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。\n　　但是采用synchronized关键字来实现同步的话，就会导致一个问题：\n　　如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。\n　　因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。\n　　另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。\n　　总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：\n　　1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；\n　　2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。")])])}],!1,null,null,null);r.options.__file="Synchronization.md";n.default=r.exports}}]);