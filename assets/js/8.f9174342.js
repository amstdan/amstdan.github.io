(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{165:function(t,e,n){"use strict";n.r(e);var s=n(0),a=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"策略模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#策略模式","aria-hidden":"true"}},[this._v("#")]),this._v(" 策略模式")]),this._v(" "),e("p",[this._v("策略模式是对面向接口编程，而不是面向类的完美诠释。当某个操作可能会有多种情型，使用if...else判断将会难以维护。\n当有更多的情型时，将不断修改维护if...else代码。使有组合将会避免这些困扰。")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('public interface Strategy {\n\tvoid operate();\n}\n\npublic class StrategyA implements Strategy {\n\tpublic void operate() {\n\t\tSystem.out.println("I\'m strategy A.");\n\t}\n}\n\npublic class StrategyB implements Strategy {\n\tpublic void operate() {\n\t\tSystem.out.println("I\'m strategy B.");\n\t}\n}\n\npublic class StrategyC implements Strategy {\n\tpublic void operate() {\n\t\tSystem.out.println("I\'m strategy C.");\n\t}\n}\n\npublic class Context {\n   private Strategy strategy;\n \n   public Context(Strategy strategy){\n      this.strategy = strategy;\n   }\n \n   public void executeStrategy(){\n      return strategy.operation();\n   }\n}\n')])])])])}],!1,null,null,null);a.options.__file="strategy.md";e.default=a.exports}}]);