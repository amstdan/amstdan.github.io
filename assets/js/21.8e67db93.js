(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{173:function(r,v,a){"use strict";a.r(v);var t=a(0),e=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var r=this,v=r.$createElement,a=r._self._c||v;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收","aria-hidden":"true"}},[r._v("#")]),r._v(" 垃圾回收")]),r._v(" "),a("h3",{attrs:{id:"引用计数算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用计数算法","aria-hidden":"true"}},[r._v("#")]),r._v(" 引用计数算法")]),r._v(" "),a("p",[r._v("给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。")]),r._v(" "),a("p",[r._v("优点：实现简单，判断效率也很高。\n缺点：难以解决对象之间的相互循环引用的问题。\n应用: 微软的COM技术，使用ActionScript3的FlashPlayer,Python语言，Squirrel。")]),r._v(" "),a("h3",{attrs:{id:"根搜索算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#根搜索算法","aria-hidden":"true"}},[r._v("#")]),r._v(" 根搜索算法")]),r._v(" "),a("p",[r._v("通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连，即GC Roots到这个对象不可达，则证明些对象不可用的。")]),r._v(" "),a("p",[r._v("GC Roots对象包括下面几种：")]),r._v(" "),a("ul",[a("li",[r._v("虚拟机栈中的引用的对象")]),r._v(" "),a("li",[r._v("方法区中的类静态属性引用的对象")]),r._v(" "),a("li",[r._v("方法区中的常量引用的对象")]),r._v(" "),a("li",[r._v("本地方法栈中JNI的引用的对象"),a("br"),r._v("\n应用： Java , C#, Lisp")])]),r._v(" "),a("h2",{attrs:{id:"引用和垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用和垃圾回收","aria-hidden":"true"}},[r._v("#")]),r._v(" 引用和垃圾回收")]),r._v(" "),a("ul",[a("li",[r._v("强引用：指类似“Object obj = new Object()”的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。")]),r._v(" "),a("li",[r._v("软引用：用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。JDK1.2后，提供了SoftReference类来实现软引用。")]),r._v(" "),a("li",[r._v("弱引用： 用来描述非必需对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论内存是否足够，都会回收掉只被弱引用关联的对象。JDK1.2后提供了WeakReference类来实现弱引用。")]),r._v(" "),a("li",[r._v("虚引用：最弱的一种引用有关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2后，PhantomReference类来实现虚引用。")])]),r._v(" "),a("h2",{attrs:{id:"垃圾收集算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集算法","aria-hidden":"true"}},[r._v("#")]),r._v(" 垃圾收集算法")]),r._v(" "),a("h3",{attrs:{id:"标记-清除算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记-清除算法","aria-hidden":"true"}},[r._v("#")]),r._v(" 标记 - 清除算法")]),r._v(" "),a("p",[r._v("首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，是最基础的收集算法。\n主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外 一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。")]),r._v(" "),a("h3",{attrs:{id:"复制算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复制算法","aria-hidden":"true"}},[r._v("#")]),r._v(" 复制算法")]),r._v(" "),a("p",[r._v("为了解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这要使用得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。")]),r._v(" "),a("p",[r._v("利用复制算法回收新生代，新生代大部分对象死的快，不需要1：1等分，将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。当Survivor空间不够用时，需要依赖老年代进行分配担保。")]),r._v(" "),a("h3",{attrs:{id:"标记-整理-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记-整理-算法","aria-hidden":"true"}},[r._v("#")]),r._v(" 标记 - 整理 算法")]),r._v(" "),a("p",[r._v("对于存活率较高对象，复制算法需要执行较多的复制操作，效率将会很低。\n因些，根据老年代的特点，先标记出所有需要回收的对象，然后让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。")]),r._v(" "),a("h2",{attrs:{id:"内存分配与回收策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存分配与回收策略","aria-hidden":"true"}},[r._v("#")]),r._v(" 内存分配与回收策略")]),r._v(" "),a("ul",[a("li",[a("p",[r._v("大多数情况，对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，发起Minor GC。")])]),r._v(" "),a("li",[a("p",[r._v("大对象直接进入老年代。所谓大对象是指，需要大量连续内存空间的Java对象。最典型的大对象就是\n那种很长的字符串及数组。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。")])]),r._v(" "),a("li",[a("p",[r._v("长期存活的对象将进入老年代。虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一次Minor GC ,年龄就增加1岁，当它的年龄增加到一定程序时，就会被晋升到老年代中。")])]),r._v(" "),a("li",[a("p",[r._v("如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须达到要求的年龄。")])]),r._v(" "),a("li",[a("p",[r._v("空间分配担保。当出现大量对象在Minor GC后仍然存活的情况时，就需要老年代进行分配担保，让Survivor无法容纳的对象直接进入老年代，在些之前，需要取之前每一次加收晋升到老年代对象对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。")])])])])}],!1,null,null,null);e.options.__file="gc.md";v.default=e.exports}}]);